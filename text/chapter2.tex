\chapter{基礎概念}

本章では、本研究が提案するシステム設計および実装の基盤となる概念と技術的背景について述べる。まず、展示の主体であるキュレーターの役割の変化と、デジタル展示における課題を整理する。次に、その解決手段としての AR （拡張現実）技術の定義と分類について概説する。続いて、実装環境である Unity および Meta XR SDK の特性を述べ、本研究の核心技術である HybridCLR を用いたホットアップデート機構、およびシステム全体の運用を支える通信アーキテクチャについて詳述する。

\section{キュレーションの変遷と定義}

\subsection{博物館における伝統的役割}

伝統的にキュレーター（学芸員）は、博物館法や ICOM （国際博物館会議）の規定に基づき、資料の収集、保存、調査研究、および展示企画を専門的に担う職種として定義されてきた。博物館という制度的枠組みの中で、歴史的かつ芸術的価値を持つ資料を体系化し、教育的配慮のもとで公衆へ提示することがその主たる役割であった。

\subsection{インディペンデントキュレーターの台頭}

近年、特定の博物館組織に所属せず、独自の文脈とテーマ設定によって展覧会を構成するインディペンデントキュレーターの活動が顕著となっている。Obrist ら[1]が指摘するように、現代のキュレーターの役割は単なる管理や保存から、新たな意味を創出するプロデューサーとしての側面を強めている。彼らの活動領域は物理空間にとどまらず、デジタル技術を用いた空間表現にも及んでおり、展示空間そのものの再定義を行っている。

\subsection{本研究における定義と課題}

AR を用いた空間芸術展示において、キュレーターの役割は鑑賞体験全体の設計者へと拡張されている。しかし、高度なデジタル技術の導入は、鑑賞者に対するデバイス操作説明やアプリケーション導入支援といった、展示の本質とは異なるコミュニケーションコストの増大を招いているのが現状である。
本研究では、Unity 等の技術的背景を持つか否かに関わらず、デジタル空間で展示構成を行い、鑑賞者へ体験を提供する主体として「キュレーター」を定義する。その上で、技術的な障壁を取り除き、彼らが表現活動に専念できる環境の構築を目指す。

\section{拡張現実技術}

\subsection{拡張現実の定義}

AR （Augmented Reality）とは、実世界の情報にコンピュータ生成情報をリアルタイムに重畳し、人間の知覚を拡張する技術である。Azuma [2]による定義では、以下の 3 要素を満たすものとされる。

\begin{itemize}
    \item 現実と仮想の結合（Combines real and virtual）
    \item リアルタイムなインタラクション（Interactive in real time）
    \item 三次元的な位置合わせ（Registered in 3D）
\end{itemize}

\subsection{ロケーションベース AR}

ロケーションベース AR は、GPS （全地球測位システム）や磁気センサ、加速度センサ等の位置情報を利用し、特定の地理的座標にデジタルコンテンツを配置する手法である（図\ref{fig:location_based_ar}）。
本手法はPokemon GOに代表されるような広域な屋外展示には適している。しかし、屋内においては GPS 信号の遮断により位置特定精度が著しく低下することや、高さ方向の正確な整合（レジストレーション）に課題が残る場合が多く、ミリ単位の配置精度が求められる精密な芸術作品の展示には不向きである。

% ロケーションベースARの図
\begin{figure}[htbp]
\begin{center}
\includegraphics[width=80mm]{./figs/基礎概念/ロケーションベースAR.png}
\caption{ロケーションベースARの概念図 [5]}
\label{fig:location_based_ar}
\end{center}
\end{figure}

\subsection{マーカ型ビジョンベース AR}

マーカ型ビジョンベース AR は、特定の画像（マーカ）をカメラで認識し、その特徴量に基づいてデジタルコンテンツの表示位置や傾きを決定する手法である（図\ref{fig:marker_based_ar}）。
本研究では、AR コンテンツの識別子（ID）と空間的な配置基準点（空間アンカー）の両方の機能を併せ持つ QR コードをマーカとして採用する。QR コードを用いることで、画像認識の安定性が向上し、鑑賞者は意図した作品を正確な位置座標で呼び出すことが可能となる。

% マーカ型ビジョンベースARの図
\begin{figure}[htbp]
\begin{center}
\includegraphics[width=80mm]{./figs/基礎概念/マーカ型ビジョンベースAR.png}
\caption{マーカ型ビジョンベースARの概念図 [5]}
\label{fig:marker_based_ar}
\end{center}
\end{figure}

\subsection{マーカレス型ビジョンベース AR}

マーカレス型ビジョンベース AR は、特定のマーカを必要とせず、SLAM （Simultaneous Localization and Mapping）技術等を用いて周囲の環境形状をリアルタイムに解析し認識する手法である（図\ref{fig:markerless_ar}）。
本研究で使用する HMD （ヘッドマウントディスプレイ）である Meta Quest 3 等の最新デバイスでは、深度センサとカメラを用いた高度な空間認識が可能であり、壁面や床面を物理的な制約としてデジタルコンテンツに反映させることができる。しかし、この方式は環境特徴点の抽出と追跡に多大な計算リソースを要するため、モバイル HMD 単体での動作においては、マーカ型と比較してリアルタイム性および長時間稼働時の安定性に課題が残る。

% マーカレス型ビジョンベースARの図
\begin{figure}[htbp]
\begin{center}
\includegraphics[width=80mm]{./figs/基礎概念/マーカレス型ビジョンベースAR.png}
\caption{マーカレス型ビジョンベースARの概念図 [5]}
\label{fig:markerless_ar}
\end{center}
\end{figure}

\section{Unity 開発プラットフォーム}

\subsection{Unity (ユニティ)}

Unity は Unity Technologies 社[3]が提供するリアルタイム 3D 開発プラットフォームであり、現在の XR コンテンツ開発におけるデファクトスタンダードである。物理演算、レンダリング、オーディオ処理などの機能が統合されたゲームエンジンであり、C\# スクリプトによる柔軟なロジック記述が可能であることから、ゲーム産業のみならず建築、自動車、学術研究など多岐にわたる分野で利用されている。

\subsection{Prefab (プレハブ)}

Prefab は GameObject、コンポーネント（C\# スクリプト）、およびプロパティ設定を一つのアセットとしてテンプレート化する機能である。これにより、展示作品を構成する複雑なオブジェクト群（3Dモデル、テクスチャ、アニメーション、挙動スクリプト等）を一つの単位として管理し、実行時に動的に生成（インスタンス化）または破棄することが容易となる。

\subsection{AssetBundle (アセットバンドル)}

AssetBundle は Unity のアセットを実行時に外部からロード可能な形式でアーカイブする機能である。本研究では、1 つの展示作品を 1 つの AssetBundle に対応させる設計を採用している。これにより、アプリケーション本体（バイナリ）を更新することなく、サーバ上のアーカイブファイルを差し替えるだけで、コンテンツの追加や更新を行うことが可能となる。

\subsection{MonoBehaviour}

MonoBehaviour は、Unity におけるすべてのスクリプトコンポーネントが継承すべき基底クラスである。本クラスを継承することで、スクリプトは GameObject にアタッチ可能なコンポーネントとして機能し、Unity のイベントライフサイクル（Start, Update, OnDestroy 等）にフックされる。
本研究において、各展示作品の固有の振る舞い（アニメーション制御やインタラクション処理）はすべて MonoBehaviour を継承した C\# クラスとして実装される。これにより、Unity のインスペクタ上でのパラメータ調整が可能となり、開発効率とメンテナンス性が担保される。

\subsection{UUID (GUID)}

Unity はプロジェクト内のアセット（ファイル）を管理するために、ファイルパスではなく、UUID （Universally Unique Identifier）、Unity 上では一般に GUID （Global Unique Identifier）と呼ばれる一意の識別子を使用する。

ファイル名やディレクトリ構造が変更された場合でも、GUID が維持されている限り、Unity はアセット間の参照関係（例えば、Prefab がどのテクスチャを使用しているか等）を正しく解決できる。本研究のホットアップデート機構においても、サーバから取得したリソースとローカルのスクリプトを正しくリンクさせるために、この一意性が重要な役割を果たす。

\subsection{Assembly}

Assembly （アセンブリ）とは、C\# コードがコンパイルされた後のバイナリ単位（.dll）を指す。Unity では通常、ユーザーが記述したスクリプトは 「Assembly-CSharp.dll」 という単一のアセンブリにコンパイルされる。
しかし、大規模な開発や本研究のような動的な機能追加を行う場合、コードを機能ごとに分割し、独自の Assembly Definition （アセンブリ定義）を作成して管理することが推奨される。後述する HybridCLR は、このアセンブリ単位でのロードと実行制御を行うことで、スクリプトのホットアップデートを実現している。

\subsection{Metaファイル}

Unity プロジェクト内のすべてのアセットファイルには、対となる 「.meta」 ファイルが自動生成される。このメタファイルには、前述の GUID や、アセットごとのインポート設定（テクスチャの圧縮形式やモデルのスケール設定等）が記録されている。

バージョン管理システムを利用する際や、外部からアセットを取り込む際には、このメタファイルを正しく同期させる必要がある。メタファイルの欠損や不整合は参照切れ（Missing Reference）を引き起こし、アプリケーションの動作不全に直結するためである。

\subsection{制約と課題}

標準的な Unity の仕様において、AssetBundle はテクスチャやモデルデータなどの非コードアセットの更新には適しているが、コンパイル済みのロジック（C\# スクリプト）の更新を含めることはできない。これは、インタラクションの挙動を変更したい場合にアプリ全体の再ビルドとストアへの再配布が必要となることを意味し、展示運営上の大きなボトルネックとなっていた。本研究では、後述する HybridCLR を導入することでこの制約を突破する。

\section{Meta XR All-in-One SDK}

\subsection{パススルー機能}

Meta XR SDK は、Meta Quest シリーズのハードウェア機能を Unity 上で制御するための開発キットである。特に本研究では、外部カメラで取得した現実映像に CG を合成するカラーパススルー機能を活用する。これにより、現実空間と展示コンテンツがシームレスに融合した AR （Mixed Reality）体験を構築し、鑑賞者が現実の展示会場の文脈を失うことなく作品を鑑賞できる環境を提供する。

\subsection{Meta XR Interaction SDK}

Meta XR Interaction SDK は、ハンドトラッキングやコントローラ操作を抽象化し、標準的なインタラクションを提供するライブラリである。本 SDK を用いることで、開発者はハードウェアごとの差異を意識することなく実装が可能となる。また、鑑賞者は「掴む（Grab）」「指差す（Poke）」といった直感的な身体動作で AR コンテンツを操作することが可能となり、没入感を阻害しない自然な操作体系（NUI: Natural User Interface）が実現される。

\subsection{Meta XR Voice SDK}

Meta XR Voice SDK は音声認識モジュールであり、アプリケーションに対して音声入力インターフェースを提供する。本 SDK は、マイクから取得した音声データの正規化やストリーミング処理を担い、後述する自然言語処理プラットフォーム Wit.AI との通信を仲介する。これにより、HMD 装着時のハンズフリー操作や、コントローラでは表現しきれない「作品解説の呼び出し」「シーン切り替え」といった抽象度の高いコマンドを、直感的な音声入力によって実装することが可能となる。

\subsection{Wit.AI}

Wit.AI は Meta 社が提供する自然言語処理（Natural Language Processing）プラットフォームであり、ユーザーの非構造化データ（音声やテキスト）をコンピュータが処理可能な構造化データへと変換するクラウドサービスである。本研究において、Wit.AI は鑑賞者の発話意図を解析し、具体的な操作命令へと変換する核心的なエンジンとして機能する。Wit.AI の処理プロセスは図\ref{fig:witai_process}に示すように、主に以下の要素によって構成される。

% Wit.AIの処理プロセスの図
\begin{figure}[htbp]
\begin{center}
\includegraphics[width=80mm]{./figs/基礎概念/Wit.AIの処理プロセス.png}
\caption{Wit.AIにおける音声処理プロセス [5]}
\label{fig:witai_process}
\end{center}
\end{figure}

\begin{itemize}
    \item \textbf{Intent (インテント)}: ユーザーの発話が「何をしようとしているのか」という意図を定義したものである。例えば、「解説を再生して」や「次の作品へ移動」といった発話に対し、それぞれ \texttt{PlayDescription} や \texttt{MoveToNext} といった識別子を割り当てる。システムは返却されたインテント識別子に基づき、実行すべき C\# メソッドを決定する。
    \item \textbf{Entity (エンティティ)}: 発話に含まれる具体的なパラメータや変数を抽出するための定義である。例えば、「作品Aを見せて」という発話において、「見せて」はインテントであるが、「作品A」は操作対象を特定する重要な変数である。Wit.AI は事前に学習させたキーワードや文脈に基づき、このような固有名称を抽出し、引数としてアプリケーションへ返却する。
    \item \textbf{Trait (トレイト)}: 発話全体の意味合いやニュアンスを分類する機能である。肯定（Yes）または否定（No）の判定や感情分析などに用いられる。これにより、確認ダイアログに対する応答判定などが容易になり、より自然な対話フローの構築が可能となる。
\end{itemize}

これらの機能により、Wit.AI は単なる音声のテキスト化（Speech-to-Text）にとどまらず、文脈理解（Natural Language Understanding）を伴う高度なインタラクションを実現する。

\section{HybridCLR とホットアップデート}

\subsection{IL2CPP の技術的課題}

Unity の標準的なビルド方式である IL2CPP （Intermediate Language to C++）モードでは、C\# コードがビルド時に C++ へ事前コンパイル（AOT: Ahead-Of-Time）される。この仕組みにより、実行速度の向上やセキュリティの確保が可能となる反面、実行中に新たな C\# コード（アセンブリ）を動的に読み込んで実行することは、メモリ管理や実行権限の構造上、不可能であった。

\subsection{HybridCLR の導入}

HybridCLR [4]は、この IL2CPP 環境下において、AOT 実行とインタープリタ実行を混在させることで、C\# の完全なホットアップデートを実現する革新的なフレームワークである。HybridCLR は、IL2CPP のランタイムを拡張し、コンパイル済みのネイティブバイナリ上で、サーバからダウンロードした DLL （アセンブリ）内のメタデータと IL 命令を直接解釈・実行するインタプリタ機能を提供する。

\subsection{AddComponent ベースの更新}

これは、実行時（ランタイム）にロードしたアセンブリ内のクラス情報を利用し、\texttt{AddComponent} メソッドを通じて既存の GameObject に新たなコンポーネント（ロジック）を動的に付与する手法である。これにより、アプリリリース時には存在しなかった全く新しい機能を作品に追加できる。本研究ではこの技術を採用することで、キュレーターが作成した複雑なインタラクションロジックを、AssetBundle として鑑賞者アプリへ即座に反映させることを可能にしている。

\subsection{Asset ベースの更新}

これは、Prefab 内にシリアライズされたスクリプト参照を、実行時にロードした最新のスクリプトコードへと自動的に解決（リマップ）する手法である。
ただし、技術的な注意点として、スクリプトをデシリアライズする際には、生成時と同一のメタデータ構造を保持している必要がある。そのため、異なる Unity プロジェクトで生成された Prefab は、GUID の不一致等により中身のスクリプトを自動的にリマップできない場合がある。本研究では、この制約を考慮したアセット管理フローを構築している。

\section{静的ファイル配信サーバ}

本システムにおけるサーバは、動的なプログラム処理（アプリケーションロジック）を持たず、クライアントからのリクエストに応じてファイル（映像、3Dモデル、AssetBundle 等）を配信することに特化した静的ファイルサーバである。
実装には ASP.NET Core を採用している。これにより、サーバサイドとクライアント（Unity）間で C\# 言語による統一的なデータ定義が可能となり、保守性を向上させている。

\section{システムアーキテクチャ}

提案システムはクライアント・サーバモデルを採用し、以下の 3 つの主要コンポーネントから構成される（図\ref{fig:proposed_system}）。

% 提案システム構成の図
\begin{figure}[htbp]
\begin{center}
\includegraphics[width=80mm]{./figs/基礎概念/提案システム構成.png}
\caption{提案システムの全体構成図 [5].}
\label{fig:proposed_system}
\end{center}
\end{figure}

\begin{itemize}
    \item \textbf{ARShowNode}: AR 展示物の作成とアップロードを行うキュレーター側プログラム
    \item \textbf{ARShow}: 閲覧者用クライアントアプリケーション
    \item \textbf{Static File Server}: コンテンツを配信する静的ファイルサーバ
\end{itemize}

この 3 つの部分が有機的に連携することにより、キュレーターは自身のコンテンツを容易に配信かつ更新でき、閲覧者は最新の展示物をシームレスに体験できる環境が実現される。

展示作品の実体である AssetBundle は、アプリケーション内部には保持されず、外部サーバに配置される。クライアントアプリは QR コードの読み取りをトリガーとして、必要なデータのみをオンデマンドで取得し展開する。このアーキテクチャにより、鑑賞者のデバイスストレージを圧迫することなく、作品数を無制限に拡張することが可能となる。また、展示内容の更新はサーバ側のアーカイブファイル差し替えのみで完結するため、前述した「更新プロセスの困難さ」および「コミュニケーションコスト」の課題を根本から解決する基盤となる。


参考文献 (References)
[1] Obrist, H. U. (2014). Ways of Curating. Faber \& Faber.
[2] Azuma, R. T. (1997). A Survey of Augmented Reality. Presence: Teleoperators and Virtual Environments, 6(4), 355-385.
[3] Unity Technologies. (2024). Unity User Manual. https://docs.unity3d.com/
[4] HybridCLR. (2024). HybridCLR Documentation. https://github.com/focus-creative-games/hybridclr
