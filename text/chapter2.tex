\chapter{技術説明}

本章では、本研究が提案するシステム設計および実装の基盤となる概念と技術的背景について述べる。まず、展示の主体であるキュレーターの役割の変化と、デジタル展示における課題を整理する。次に、その解決手段としての AR （拡張現実）技術の定義と分類について概説する。続いて、実装環境である Unity および Meta XR SDK の特性を述べ、本研究の核心技術である HybridCLR を用いたホットアップデート機構、およびシステム全体の運用を支える通信アーキテクチャについて詳述する。

\section{キュレーションの変遷と定義}

\subsection{博物館における伝統的役割}

伝統的にキュレーター（学芸員）は、博物館法や ICOM （国際博物館会議）の規定に基づき、資料の収集、保存、調査研究、および展示企画を専門的に担う職種として定義されてきた。博物館という制度的枠組みの中で、歴史的かつ芸術的価値を持つ資料を体系化し、教育的配慮のもとで公衆へ提示することがその主たる役割であった。

\subsection{インディペンデントキュレーターの台頭}

近年、特定の博物館組織に所属せず、独自の文脈とテーマ設定によって展覧会を構成するインディペンデントキュレーターの活動が顕著となっている。Obrist ら[1]が指摘するように、現代のキュレーターの役割は単なる管理や保存から、新たな意味を創出するプロデューサーとしての側面を強めている。彼らの活動領域は物理空間にとどまらず、デジタル技術を用いた空間表現にも及んでおり、展示空間そのものの再定義を行っている。

\subsection{本研究における定義と課題}

AR を用いた空間芸術展示において、キュレーターの役割は鑑賞体験全体の設計者へと拡張されている。しかし、高度なデジタル技術の導入は、鑑賞者に対するデバイス操作説明やアプリケーション導入支援といった、展示の本質とは異なるコミュニケーションコストの増大を招いているのが現状である。本研究では、デジタル空間で展示構成を行い、鑑賞者へ体験を提供する主体として「キュレーター」を定義する。その上で、技術的な障壁を取り除き、彼らが表現活動に専念できる環境の構築を目指す。

\section{拡張現実技術}

\subsection{AR の定義}

AR （Augmented Reality）とは、実世界の情報にコンピュータ生成情報をリアルタイムに重畳し、人間の知覚を拡張する技術である。Azuma [1]による定義では、以下の 3 要素を満たすものとされる。

\begin{itemize}
    \item 現実と仮想の結合（Combines real and virtual）
    \item リアルタイムなインタラクション（Interactive in real time）
    \item 三次元的な位置合わせ（Registered in 3D）
\end{itemize}

\subsection{ロケーションベース AR}

ロケーションベース AR は、GPS （全地球測位システム）や磁気センサ、加速度センサ等の位置情報を利用し、特定の地理的座標にデジタルコンテンツを配置する手法である（図\ref{fig:location_based_ar}）。本手法はPokemon GOに代表されるような広域な屋外展示には適している。しかし、屋内においては GPS 信号の遮断により位置特定精度が著しく低下することや、高さ方向の正確な整合（レジストレーション）に課題が残る場合が多く、ミリ単位の配置精度が求められる精密な芸術作品の展示には不向きである。

% ロケーションベースARの図
\begin{figure}[htbp]
\begin{center}
\includegraphics[width=80mm]{./figs/基礎概念/ロケーションベースAR.png}
\caption{ロケーションベースARの概念図 [5]}
\label{fig:location_based_ar}
\end{center}
\end{figure}

\subsection{マーカ型ビジョンベース AR}

マーカ型ビジョンベース AR は、特定の画像（マーカ）をカメラで認識し、その特徴量に基づいてデジタルコンテンツの表示位置や傾きを決定する手法である（図\ref{fig:marker_based_ar}）。本研究では、AR コンテンツの識別子（ID）と空間的な配置基準点（空間アンカー）の両方の機能を併せ持つ QR コードをマーカとして採用する。QR コードを用いることで、画像認識の安定性が向上し、鑑賞者は意図した作品を正確な位置座標で呼び出すことが可能となる。

% マーカ型ビジョンベースARの図
\begin{figure}[htbp]
\begin{center}
\includegraphics[width=80mm]{./figs/基礎概念/マーカ型ビジョンベースAR.png}
\caption{マーカ型ビジョンベースARの概念図 [5]}
\label{fig:marker_based_ar}
\end{center}
\end{figure}

\subsection{マーカレス型ビジョンベース AR}

マーカレス型ビジョンベース AR は、特定のマーカを必要とせず、SLAM （Simultaneous Localization and Mapping）技術等を用いて周囲の環境形状をリアルタイムに解析し認識する手法である（図\ref{fig:markerless_ar}）。本研究で使用する HMD （ヘッドマウントディスプレイ）である Meta Quest 3 等の最新デバイスでは、深度センサとカメラを用いた高度な空間認識が可能であり、壁面や床面を物理的な制約としてデジタルコンテンツに反映させることができる。しかし、この方式は環境特徴点の抽出と追跡に多大な計算リソースを要するため、モバイル HMD 単体での動作においては、マーカ型と比較してリアルタイム性および長時間稼働時の安定性に課題が残る。

% マーカレス型ビジョンベースARの図
\begin{figure}[htbp]
\begin{center}
\includegraphics[width=80mm]{./figs/基礎概念/マーカレス型ビジョンベースAR.png}
\caption{マーカレス型ビジョンベースARの概念図 [5]}
\label{fig:markerless_ar}
\end{center}
\end{figure}

\section{Unity 関連技術}

\subsection{Unity}

Unity は Unity Technologies 社[3]が提供するリアルタイム 3D 開発プラットフォームであり、現在の XR コンテンツ開発におけるデファクトスタンダードである。物理演算、レンダリング、オーディオ処理などの機能が統合されたゲームエンジンであり、C\# スクリプトによる柔軟なロジック記述が可能であることから、ゲーム産業のみならず建築、自動車、学術研究など多岐にわたる分野で利用されている。

\subsection{Prefab}

Prefab は GameObject、コンポーネント（C\# スクリプト）、およびプロパティ設定を一つのアセットとしてテンプレート化する機能である。これにより、展示作品を構成する複雑なオブジェクト群（3Dモデル、テクスチャ、アニメーション、挙動スクリプト等）を一つの単位として管理し、実行時に動的に生成（インスタンス化）または破棄することが容易となる。

\subsection{MonoBehaviour}

MonoBehaviour は、Unity におけるすべてのスクリプトコンポーネントが継承すべき基底クラスである。本クラスを継承することで、スクリプトは GameObject にアタッチ可能なコンポーネントとして機能し、Unity のイベントライフサイクル（Start, Update, OnDestroy 等）にフックされる。
本研究において、各展示作品の固有の振る舞い（アニメーション制御やインタラクション処理）はすべて MonoBehaviour を継承した C\# クラスとして実装される。これにより、Unity のインスペクタ上でのパラメータ調整が可能となり、開発効率とメンテナンス性が担保される。

\subsection{Assembly}

Assembly （アセンブリ）とは、C\# コードがコンパイルされた後のバイナリ単位（.dll）を指す。Unity では通常、ユーザーが記述したスクリプトは「Assembly-CSharp.dll」という単一のアセンブリにコンパイルされる。しかし、大規模な開発や本研究のような動的な機能追加を行う場合、コードを機能ごとに分割し、独自の Assembly Definition（アセンブリ定義）を作成して管理することが推奨される。後述する HybridCLR は、このアセンブリ単位でのロードと実行制御を行うことで、スクリプトのホットアップデートを実現している。

\subsection{UUID}

Unity はプロジェクト内のアセット（ファイル）を管理するために、ファイルパスではなく、UUID （Universally Unique Identifier）、Unity 上では一般に GUID （Global Unique Identifier）と呼ばれる一意の識別子を使用する。

ファイル名やディレクトリ構造が変更された場合でも、GUID が維持されている限り、Unity はアセット間の参照関係（例えば、Prefab がどのテクスチャを使用しているか等）を正しく解決できる。本研究のホットアップデート機構においても、サーバから取得したリソースとローカルのスクリプトを正しくリンクさせるために、この一意性が重要な役割を果たす。

\subsection{Asset}

これは、Prefab 内にシリアライズされたスクリプト参照を、実行時にロードした最新のスクリプトコードへと自動的に解決（リマップ）する手法である。ただし、技術的な注意点として、スクリプトをデシリアライズする際には、生成時と同一のメタデータ構造を保持している必要がある。そのため、異なる Unity プロジェクトで生成された Prefab は、UUID の不一致等により中身のスクリプトを自動的にリマップできない場合がある。本研究では、この制約を考慮したアセット管理フローを構築している。

\subsection{AssetBundle}

AssetBundle は Unity のアセットを実行時に外部からロード可能な形式でアーカイブする機能である。本研究では、1 つの展示作品を 1 つの AssetBundle に対応させる設計を採用している。これにより、アプリケーション本体（バイナリ）を更新することなく、サーバ上のアーカイブファイルを差し替えるだけで、コンテンツの追加や更新を行うことが可能となる。

\subsection{メタファイル}

Unity プロジェクト内のすべてのアセットファイルには、対となる 「.meta」 ファイルが自動生成される。このメタファイルには、前述の GUID や、アセットごとのインポート設定（テクスチャの圧縮形式やモデルのスケール設定等）が記録されている。

バージョン管理システムを利用する際や、外部からアセットを取り込む際には、このメタファイルを正しく同期させる必要がある。メタファイルの欠損や不整合は参照切れ（Missing Reference）を引き起こし、アプリケーションの動作不全に直結するためである。

\section{Meta XR All-in-One SDK}

\subsection{パススルー機能}

Meta XR SDK は、Meta Quest シリーズのハードウェア機能を Unity 上で制御するための開発キットである。特に本研究では、外部カメラで取得した現実映像に CG を合成するカラーパススルー機能を活用する。これにより、現実空間と展示コンテンツがシームレスに融合した AR （Mixed Reality）体験を構築し、鑑賞者が現実の展示会場の文脈を失うことなく作品を鑑賞できる環境を提供する。

\subsection{Meta XR Interaction SDK}

Meta XR Interaction SDK は、ハンドトラッキングやコントローラ操作を抽象化し、標準的なインタラクションを提供するライブラリである。本 SDK を用いることで、開発者はハードウェアごとの差異を意識することなく実装が可能となる。また、鑑賞者は「掴む（Grab）」「指差す（Poke）」といった直感的な身体動作で AR コンテンツを操作することが可能となり、没入感を阻害しない自然な操作体系（NUI: Natural User Interface）が実現される。

\subsection{Meta XR Voice SDK}

Meta XR Voice SDK は音声認識モジュールであり、アプリケーションに対して音声入力インターフェースを提供する。本 SDK は、マイクから取得した音声データの正規化やストリーミング処理を担い、後述する自然言語処理プラットフォーム WitAI との通信を仲介する。これにより、HMD 装着時のハンズフリー操作や、コントローラでは表現しきれない「作品解説の呼び出し」「シーン切り替え」といった抽象度の高いコマンドを、直感的な音声入力によって実装することが可能となる。

\subsection{WitAI}

WitAI は Meta 社が提供する自然言語処理（Natural Language Processing）プラットフォームであり、ユーザーの非構造化データ（音声やテキスト）をコンピュータが処理可能な構造化データへと変換するクラウドサービスである。本研究において、WitAI は鑑賞者の発話意図を解析し、具体的な操作命令へと変換する核心的なエンジンとして機能する。WitAI の処理プロセスは図\ref{fig:witai_process}に示すように、主に以下の要素によって構成される。

% WitAIの処理プロセスの図
\begin{figure}[htbp]
\begin{center}
\includegraphics[width=80mm]{./figs/基礎概念/Wit.AIの処理プロセス.png}
\caption{Wit.AIにおける音声処理プロセス [5]}
\label{fig:witai_process}
\end{center}
\end{figure}

\begin{itemize}
    \item \textbf{Intent（インテント）}: ユーザーの発話が「何をしようとしているのか」という意図を定義したものである。例えば、「解説を再生して」や「次の作品へ移動」といった発話に対し、それぞれ「PlayDescription」や「MoveToNext」といった識別子を割り当てる。システムは返却されたインテント識別子に基づき、実行すべき C\# メソッドを決定する。
    \item \textbf{Entity（エンティティ）}: 発話に含まれる具体的なパラメータや変数を抽出するための定義である。例えば、「作品Aを見せて」という発話において、「見せて」はインテントであるが、「作品A」は操作対象を特定する重要な変数である。Wit.AI は事前に学習させたキーワードや文脈に基づき、このような固有名称を抽出し、引数としてアプリケーションへ返却する。
    \item \textbf{Trait（トレイト）}: 発話全体の意味合いやニュアンスを分類する機能である。肯定（Yes）または否定（No）の判定や感情分析などに用いられる。これにより、確認ダイアログに対する応答判定などが容易になり、より自然な対話フローの構築が可能となる。
\end{itemize}

これらの機能により、Wit.AI は単なる音声のテキスト化（Speech-to-Text）にとどまらず、文脈理解（Natural Language Understanding）を伴う高度なインタラクションを実現する。

\section{ホットアップデート技術}

\subsection{IL2CPP}

Unity の標準的なビルド方式である IL2CPP （Intermediate Language to C++）モードでは、C\# コードがビルド時に C++ へ事前訳出（AOT: Ahead-Of-Time）される。この仕組みにより、実行速度の向上やセキュリティの確保が可能となる反面、実行中に新たな C\# コード（アセンブリ）を動的に読み込んで実行することは、メモリ管理や実行権限の構造上、不可能であった。

\subsection{HybridCLR}

C\# は IL（Intermediate Language）を前提とし、ホットアップデートが容易な言語として、IL2CPP の制約を受けその利点を十分に活かせていなかった。HybridCLR は、この IL2CPP 環境下において AOT 実行とインタープリタ実行を混在させることで、C\# のホットアップデートを復活させたフレームワークである。図\ref{fig:HybridCLR}のように示し、HybridCLR は IL2CPP のランタイムを拡張し、サーバからダウンロードされた DLL （アセンブリ）内のメタデータと IL 命令を直接解釈し実行するインタプリタ機能を提供する。その一方、この方式でセキュリティリスクを増大させる可能性があるため、HybridCLR は信頼できるソースからのアセンブリのみをロードすべきである。

% HybridCLR構成図
\begin{figure}[htbp]
\begin{center}
\includegraphics[width=80mm]{./figs/基礎概念/HybridCLR.png}
\caption{HybridCLR構成図 [5].}
\label{fig:HybridCLR}
\end{center}
\end{figure}

\subsection{AddComponent メソッド}

これは、実行時（ランタイム）にロードしたアセンブリ内のクラス情報を利用し、AddComponent メソッドを通じて既存の GameObject に新たなコンポーネント（ロジック）を動的に付与する手法である。これにより、アプリリリース時には存在しなかった全く新しい機能を AR 展品に追加できる。本研究ではこの技術を採用することで、キュレーターが作成した複雑なインタラクションロジックを、AssetBundle として鑑賞者アプリへ即座に反映させることを可能にしている。

\subsection{制約と課題}

本システムの実装および運用において、最大の課題となるのがプラットフォーム各社が定めるアプリケーションストアの審査ガイドラインとの整合性である。Apple App Store、Google Play、および Meta Quest Store 等の主要なプラットフォームでは、セキュリティ上の理由から、アプリケーション審査完了後に外部から実行可能なコード（バイナリやスクリプト）をダウンロードし、アプリの挙動を著しく変更することを原則として禁止している。本研究で採用する HybridCLR は、コンパイル済みの DLL ファイルをサーバから取得して実行する仕組みであるため、これらの規約に抵触し、ストア審査を通過できないリスクが存在する。

この課題に対する回避策として、博物館が所有するデバイスを貸し出す形式（展示側提供環境）であれば、公式ストアを経由しない「サイドロード」や、組織内向けの「エンタープライズ配信」を用いることで、規約の制約を受けずに本システムの全機能を利用可能である。これは、特定の展示施設内で完結する運用においては十分かつ現実的な解である。

\subsection{ホットアップデートの従来手段}

アプリケーション本体（バイナリ）を再ビルドと再配布することなく、コンテンツやロジックを更新する手法自体は、ゲーム開発分野においては新しい概念ではなく、既に確立された手法がいくつか存在する。ここでは、代表的な既存手法とその課題について述べ、本研究のアプローチとの差異を明確にする。

\subsubsection{AssetBundle によるリソース更新}

Unity における最も標準的な更新手法は AssetBundle の利用である。これにより、3D モデル、テクスチャ、音声データなどの「アセット」を動的にロードすることが可能である。しかし、iOS や Meta Quest 等の IL2CPP ビルド環境下では、C\# スクリプト（コンパイルされた IL コード）を AssetBundle に含めても、AOT（事前コンパイル）の制約により実行時にロードできないという技術的な制限がある。そのため、AssetBundle 単体では、展示ごとの複雑なインタラクションロジックの追加や変更には対応できない。

\subsubsection{スクリプト言語（Lua/JavaScript）の組み込み}

ロジックのホットアップデートを実現する最も一般的な手法は、Lua や JavaScript といった軽量スクリプト言語のインタプリタをアプリに内蔵する方法である。この手法では、更新対象のロジックをテキストベースのスクリプトファイルとして配信し、実行時にインタプリタがそれを解釈・実行する。これは多くの商用モバイルゲームで採用されている信頼性の高い手法である。

しかし、この手法には以下の課題が存在する。

\begin{itemize}
    \item \textbf{開発言語の分断}: アプリ本体は C\# で開発されているにもかかわらず、更新部分は Lua 等の別言語で記述する必要があり、開発者には多言語の習得が求められる。
    \item \textbf{バインディングコスト}: C\# の関数をスクリプト言語から呼び出すためには、ラッパー（バインディングコード）の生成が必要であり、これに伴う実行時のオーバーヘッド（マーシャリングコスト）が発生する。
    \item \textbf{デバッグの困難さ}: C\# とスクリプト言語を行き来する処理となるため、統合開発環境（IDE）でのデバッグやプロファイリングが複雑化する。
\end{itemize}

これに対し、本研究で採用する HybridCLR は、更新用プログラムも C\# で記述し、Unity の API をネイティブに近い形で直接利用可能にするものである。これにより、「開発環境の統一」と「バインディングコストの排除」を実現している点が、従来のスクリプト言語方式と比較した際の最大の技術的優位性である。




参考文献
[1] Azuma, R. T. (2017). A Survey of Augmented Reality, Presence: Teleoperators and Virtual Environments6.

